{
  "hash": "9ad05300b3e52d0157655e79e74d0937",
  "result": {
    "markdown": "---\ntitle: \"Introduction to single cell data science\"\nformat:\n  html:\n    toc: true\n---\n\n\n\n\n# Part 1\n\n## Learning objectives\n\n1. Learn what are genomic data and how are they generated? \n2. What is a `GRanges` object? \n3. What are some advantages of applying tidy principles to genomic data? \n4. What is a `SingleCellExperiment` object? \n\n## Materials \n\nWe will go through the slides available here: \n\n- <https://docs.google.com/presentation/d/1VFL4OxK44Q7b1c-Vk9PDnroT-R5_aQP2LRfJaHXQedo/edit?usp=sharing>\n\n\n\n\n# Part 2\n\n## Learning objectives \n\n1. Remind ourselves of basics of `tidyverse` functions (mostly `dplyr` and `ggplot2`). \n2. Introduce how to preprocess data and to perform principal components analysis (PCA), a widely used method for dimensionality reduction. \n\n\n## Palmer penguins\n\nIn this section, we give an example of using `tidyverse` functions with the \n`palmerpenguins` dataset available as a CRAN package. \n\n\n::: {.cell layout-align=\"center\" show='true' fig.caption='Palmer penguins'}\n::: {.cell-output-display}\n![](figures/lter_penguins.png){fig-align='center' width=780px}\n:::\n:::\n\n\n\\[**Source**: [Artwork by Allison Horst](https://github.com/allisonhorst/stats-illustrations)\\]\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(palmerpenguins) # penguins!\nsuppressPackageStartupMessages({\n  library(ggplot2) # \"grammar of graphics\" plots\n  library(dplyr) # data pliers\n})\n```\n:::\n\n\nWe can select first three rows and two columns: \n\n\n::: {.cell}\n\n```{.r .cell-code}\npenguins |> \n  slice(1:3) |>\n  select(species, island) \n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 3 × 2\n  species island   \n  <fct>   <fct>    \n1 Adelie  Torgersen\n2 Adelie  Torgersen\n3 Adelie  Torgersen\n```\n:::\n:::\n\n\nAnd estimate the average body mass in grams using `summarize()`: \n\n\n::: {.cell}\n\n```{.r .cell-code}\npenguins |> \n  summarize(ave_mass = mean(body_mass_g, na.rm=TRUE))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 1 × 1\n  ave_mass\n     <dbl>\n1    4202.\n```\n:::\n:::\n\nRearranging how we omit NA values, we get the same: \n\n\n::: {.cell}\n\n```{.r .cell-code}\npenguins |> \n  na.omit() |> \n  summarize(ave_mass = mean(body_mass_g))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 1 × 1\n  ave_mass\n     <dbl>\n1    4207.\n```\n:::\n:::\n\n\nOr we can also drop NA values entirely and modify our original dataset\n\n\n::: {.cell}\n\n```{.r .cell-code}\npenguins <- penguins |> \n  na.omit()\n\npenguins |> \n  summarize(ave_mass = mean(body_mass_g))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 1 × 1\n  ave_mass\n     <dbl>\n1    4207.\n```\n:::\n:::\n\n\nA powerful paradigm is to first group and then summarize: \n\n\n::: {.cell}\n\n```{.r .cell-code}\npenguins |> \n  group_by(species, island) |> \n  summarize(ave_mass = mean(body_mass_g))\n```\n\n::: {.cell-output .cell-output-stderr}\n```\n`summarise()` has grouped output by 'species'. You can override using the\n`.groups` argument.\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 5 × 3\n# Groups:   species [3]\n  species   island    ave_mass\n  <fct>     <fct>        <dbl>\n1 Adelie    Biscoe       3710.\n2 Adelie    Dream        3701.\n3 Adelie    Torgersen    3709.\n4 Chinstrap Dream        3733.\n5 Gentoo    Biscoe       5092.\n```\n:::\n:::\n\n\n## Visualization \n\nThese data can also be piped into functions for data visualization: \n\n\n::: {.cell}\n\n```{.r .cell-code}\npenguins |> \n  ggplot(aes(species, body_mass_g)) +\n  geom_boxplot(aes(fill=species))\n```\n\n::: {.cell-output-display}\n![](intro-singlecell_files/figure-html/unnamed-chunk-8-1.png){width=672}\n:::\n:::\n\n\n## Dimensionality reduction \n\nNext, we will work towards using dimensionality reduction to visualize the \npenguins in the principal components space. \n\nFor the four columns that contain `mm` or `mass`, we apply `scale()`, which \ncenters and scales each variable. \n\n\n::: {.cell}\n\n```{.r .cell-code}\npenguins |> \n  mutate(across(contains(c(\"mm\",\"mass\")), scale))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 333 × 8\n   species island    bill_length_mm[,1] bill_depth_mm[,1] flipper_length_mm[,1]\n   <fct>   <fct>                  <dbl>             <dbl>                 <dbl>\n 1 Adelie  Torgersen             -0.895             0.780                -1.42 \n 2 Adelie  Torgersen             -0.822             0.119                -1.07 \n 3 Adelie  Torgersen             -0.675             0.424                -0.426\n 4 Adelie  Torgersen             -1.33              1.08                 -0.568\n 5 Adelie  Torgersen             -0.858             1.74                 -0.782\n 6 Adelie  Torgersen             -0.931             0.323                -1.42 \n 7 Adelie  Torgersen             -0.876             1.24                 -0.426\n 8 Adelie  Torgersen             -0.529             0.221                -1.35 \n 9 Adelie  Torgersen             -0.986             2.05                 -0.711\n10 Adelie  Torgersen             -1.72              2.00                 -0.212\n# ℹ 323 more rows\n# ℹ 3 more variables: body_mass_g <dbl[,1]>, sex <fct>, year <int>\n```\n:::\n:::\n\n\nVisualizing the scaled data (i.e. y-axis has changed, but distribution is the same). \n\n\n::: {.cell}\n\n```{.r .cell-code}\npenguins |> \n  mutate(across(contains(c(\"mm\",\"mass\")), scale)) |> \n  ggplot(aes(species, body_mass_g)) +\n  geom_boxplot(aes(fill=species))\n```\n\n::: {.cell-output-display}\n![](intro-singlecell_files/figure-html/unnamed-chunk-10-1.png){width=672}\n:::\n:::\n\n\nLet's create a new matrix called `scaled` with just the four columns scaled. \n\n\n::: {.cell}\n\n```{.r .cell-code}\nscaled <- penguins |> \n  select(contains(c(\"mm\",\"mass\"))) |> \n  mutate(across(everything(), scale))\nscaled\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 333 × 4\n   bill_length_mm[,1] bill_depth_mm[,1] flipper_length_mm[,1] body_mass_g[,1]\n                <dbl>             <dbl>                 <dbl>           <dbl>\n 1             -0.895             0.780                -1.42           -0.568\n 2             -0.822             0.119                -1.07           -0.506\n 3             -0.675             0.424                -0.426          -1.19 \n 4             -1.33              1.08                 -0.568          -0.940\n 5             -0.858             1.74                 -0.782          -0.692\n 6             -0.931             0.323                -1.42           -0.723\n 7             -0.876             1.24                 -0.426           0.581\n 8             -0.529             0.221                -1.35           -1.25 \n 9             -0.986             2.05                 -0.711          -0.506\n10             -1.72              2.00                 -0.212           0.240\n# ℹ 323 more rows\n```\n:::\n:::\n\n\nThen, we can apply the function `prcomp()` to calculate the principal components 1 to 4. \n\nUnder the hood, the function uses a singular value decomposition of the centered and scaled data matrix (not using `eigen` on the covariance matrix). Often preferred for numerical accuracy. \n\n\n::: {.cell}\n\n```{.r .cell-code}\nscaled |> \n  prcomp() \n```\n\n::: {.cell-output .cell-output-stdout}\n```\nStandard deviations (1, .., p=4):\n[1] 1.6569115 0.8821095 0.6071594 0.3284579\n\nRotation (n x k) = (4 x 4):\n                         PC1         PC2        PC3        PC4\nbill_length_mm     0.4537532 -0.60019490 -0.6424951  0.1451695\nbill_depth_mm     -0.3990472 -0.79616951  0.4258004 -0.1599044\nflipper_length_mm  0.5768250 -0.00578817  0.2360952 -0.7819837\nbody_mass_g        0.5496747 -0.07646366  0.5917374  0.5846861\n```\n:::\n:::\n\n\nSome useful things about output: \n\n\n::: {.cell}\n\n```{.r .cell-code}\npca <- scaled |> \n  prcomp()\n\nnames(pca)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"sdev\"     \"rotation\" \"center\"   \"scale\"    \"x\"       \n```\n:::\n\n```{.r .cell-code}\ndim(pca$x)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 333   4\n```\n:::\n\n```{.r .cell-code}\nhead(pca$x)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n           PC1         PC2         PC3        PC4\n[1,] -1.850808 -0.03202119  0.23454869  0.5276026\n[2,] -1.314276  0.44286031  0.02742880  0.4011230\n[3,] -1.374537  0.16098821 -0.18940423 -0.5278675\n[4,] -1.882455  0.01233268  0.62792772 -0.4721826\n[5,] -1.917096 -0.81636958  0.69999797 -0.1961213\n[6,] -1.770356  0.36567266 -0.02841769  0.5046092\n```\n:::\n:::\n\n\nVisualize \n\n::: {.cell}\n\n```{.r .cell-code}\npenguins |> \n  bind_cols(pca$x) |> \n  ggplot(aes(PC1, PC2, color=species)) + \n  geom_point()\n```\n\n::: {.cell-output-display}\n![](intro-singlecell_files/figure-html/unnamed-chunk-14-1.png){width=672}\n:::\n:::\n\n\n# Part 3 \n\nIn this next section, we move into the analysis of single-cell transcriptomics data with a goal of learning the basic steps for data wrangling these data to calculate top principal components where each point is a _cell_ (instead of a _penguin_). \n\n## Learning objectives \n\n1. Be able to create a single-cell count matrix and read it into R\n2. Recognize and define the `SingleCellExperiment` S4 class in R/Bioconductor to store single-cell data\n3. Be able to describe a standard workflow for analyzing single-cell data\n4. Be able to run code for a standard workflow starting from loading a `SingleCellExperiment` in R and identifying clusters.\n\n\n## Overview \n\nNGS data from scRNA-seq experiments must be converted into a matrix of expression values. \n\nThis is **usually a count matrix** containing the number of reads (or UMIs) mapped to each gene (row) in each cell (column).\nOnce this quantification is complete, we can proceed with our downstream statistical analyses in R.\n\nConstructing a count matrix from raw scRNA-seq data requires some thought as the term \"single-cell RNA-seq\" encompasses a variety of different experimental protocols. \n\n\n## `SingleCellExperiment` Class\n\nOne of the **main strengths** of the Bioconductor project lies in the use of **a common data infrastructure** that powers interoperability across packages. \n\nUsers should be able to analyze their data using functions from different Bioconductor packages without the need to convert between formats. \n\nTo this end, the `SingleCellExperiment` class (from the `SingleCellExperiment` package) serves as the common currency for data exchange across 70+ single-cell-related Bioconductor packages. \n\nThis class implements a data structure that stores all aspects of our single-cell data - gene-by-cell expression data, per-cell metadata and per-gene annotation - and manipulate them in a synchronized manner.\n\n\n::: {.cell layout-align=\"center\" show='true' fig.caption='Overview of the structure of the `SingleCellExperiment` class. Each row of the assays corresponds to a row of the `rowData` (pink shading), while each column of the assays corresponds to a column of the `colData` and `reducedDims` (yellow shading).'}\n::: {.cell-output-display}\n![](figures/SingleCellExperiment.png){fig-align='center' width=780px}\n:::\n:::\n\n\n[[source](https://doi.org/10.1101/590562)]\n\n\n- Each piece of (meta)data in the `SingleCellExperiment` is **represented by a separate \"slot\"**.\n\n(This terminology comes from the S4 class system, but that’s not important right now). \n\nIf we imagine the `SingleCellExperiment` object to be a cargo ship, the **slots can be thought of as individual cargo boxes with different contents**, e.g., certain slots expect numeric matrices whereas others may expect data frames. \n\nIf you want to know more about the available slots, their expected formats, and how we can interact with them, check out this [chapter](https://bioconductor.org/books/3.15/OSCA.intro/the-singlecellexperiment-class.html). \n\n\n### `SingleCellExperiment` Example\n\nLet's show you what a `SingleCellExperiment` (or `sce` for short) looks like. \n\n\n::: {.cell}\n\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nsce\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nclass: SingleCellExperiment \ndim: 20006 3005 \nmetadata(0):\nassays(1): counts\nrownames(20006): Tspan12 Tshz1 ... mt-Rnr1 mt-Nd4l\nrowData names(1): featureType\ncolnames(3005): 1772071015_C02 1772071017_G12 ... 1772066098_A12\n  1772058148_F03\ncolData names(10): tissue group # ... level1class level2class\nreducedDimNames(0):\nmainExpName: endogenous\naltExpNames(2): ERCC repeat\n```\n:::\n:::\n\n\nThis `SingleCellExperiment` object has 20006 genes and 3005 cells.\n\nWe can pull out the counts matrix with the `counts()` function and the corresponding `rowData()` and `colData()`: \n\n\n::: {.cell}\n\n```{.r .cell-code}\ncounts(sce)[1:5, 1:5]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n         1772071015_C02 1772071017_G12 1772071017_A05 1772071014_B06\nTspan12               0              0              0              3\nTshz1                 3              1              0              2\nFnbp1l                3              1              6              4\nAdamts15              0              0              0              0\nCldn12                1              1              1              0\n         1772067065_H06\nTspan12               0\nTshz1                 2\nFnbp1l                1\nAdamts15              0\nCldn12                0\n```\n:::\n\n```{.r .cell-code}\nrowData(sce)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nDataFrame with 20006 rows and 1 column\n         featureType\n         <character>\nTspan12   endogenous\nTshz1     endogenous\nFnbp1l    endogenous\nAdamts15  endogenous\nCldn12    endogenous\n...              ...\nmt-Co2          mito\nmt-Co1          mito\nmt-Rnr2         mito\nmt-Rnr1         mito\nmt-Nd4l         mito\n```\n:::\n\n```{.r .cell-code}\ncolData(sce)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nDataFrame with 3005 rows and 10 columns\n                       tissue   group # total mRNA mol      well       sex\n                  <character> <numeric>      <numeric> <numeric> <numeric>\n1772071015_C02       sscortex         1           1221         3         3\n1772071017_G12       sscortex         1           1231        95         1\n1772071017_A05       sscortex         1           1652        27         1\n1772071014_B06       sscortex         1           1696        37         3\n1772067065_H06       sscortex         1           1219        43         3\n...                       ...       ...            ...       ...       ...\n1772067059_B04 ca1hippocampus         9           1997        19         1\n1772066097_D04 ca1hippocampus         9           1415        21         1\n1772063068_D01       sscortex         9           1876        34         3\n1772066098_A12 ca1hippocampus         9           1546        88         1\n1772058148_F03       sscortex         9           1970        15         3\n                     age  diameter        cell_id       level1class level2class\n               <numeric> <numeric>    <character>       <character> <character>\n1772071015_C02         2         1 1772071015_C02      interneurons       Int10\n1772071017_G12         1       353 1772071017_G12      interneurons       Int10\n1772071017_A05         1        13 1772071017_A05      interneurons        Int6\n1772071014_B06         2        19 1772071014_B06      interneurons       Int10\n1772067065_H06         6        12 1772067065_H06      interneurons        Int9\n...                  ...       ...            ...               ...         ...\n1772067059_B04         4       382 1772067059_B04 endothelial-mural       Peric\n1772066097_D04         7        12 1772066097_D04 endothelial-mural        Vsmc\n1772063068_D01         7       268 1772063068_D01 endothelial-mural        Vsmc\n1772066098_A12         7       324 1772066098_A12 endothelial-mural        Vsmc\n1772058148_F03         7         6 1772058148_F03 endothelial-mural        Vsmc\n```\n:::\n:::\n\n\n\n\n\n## A typical single-cell workflow\n\nHere, we provide an overview of the framework of a typical scRNA-seq analysis workflow:  \n\n\n::: {.cell layout-align=\"center\" show='true' fig.caption='Schematic of a typical scRNA-seq analysis workflow. Each stage (separated by dashed lines) consists of a number of specific steps, many of which operate on and modify a SingleCellExperiment instance.'}\n::: {.cell-output-display}\n![](figures/workflow.png){fig-align='center' width=780px}\n:::\n:::\n\n\n\nIn the simplest case, the workflow has the following form:\n\n1. We compute **quality control metrics** to remove low-quality cells that would interfere with downstream analyses. These cells may have been damaged during processing or may not have been fully captured by the sequencing protocol. Common metrics includes the total counts per cell, the proportion of spike-in or mitochondrial reads and the number of detected features.\n2. We convert the counts into **normalized expression values** to eliminate cell-specific biases (e.g., in capture efficiency). This allows us to perform explicit comparisons across cells in downstream steps like clustering. We also apply a transformation, typically log, to adjust for the mean-variance relationship.\n3. We perform **feature selection to pick a subset of interesting features** for downstream analysis. This is done by modelling the variance across cells for each gene and retaining genes that are highly variable. The aim is to reduce computational overhead and noise from uninteresting genes.\n4. We apply **dimensionality reduction to compact the data** and further reduce noise. Principal components analysis is typically used to obtain an initial low-rank representation for more computational work, followed by more aggressive methods like $t$-stochastic neighbor embedding for visualization purposes.\n5. We **cluster cells into groups** according to similarities in their (normalized) expression profiles. This aims to obtain groupings that serve as empirical proxies for distinct biological states. We typically interpret these groupings by identifying differentially expressed marker genes between clusters.\n\n## Quick start (simple)\n\nHere, we use the a droplet-based retina dataset from Macosko et al. (2015), provided in the `scRNAseq` package. \nThis starts from a count matrix and finishes with clusters in preparation for biological interpretation. \nWe also demonstrate how to identify differentially expressed genes between the clusters. \n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(scRNAseq)\nsce <- MacoskoRetinaData()\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nsee ?scRNAseq and browseVignettes('scRNAseq') for documentation\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nloading from cache\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nsee ?scRNAseq and browseVignettes('scRNAseq') for documentation\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nloading from cache\n```\n:::\n\n```{.r .cell-code}\n# Quality control (using mitochondrial genes).\nlibrary(scater)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nLoading required package: scuttle\n```\n:::\n\n```{.r .cell-code}\nis.mito <- grepl(\"^MT-\", rownames(sce)) # find mitochondrial genes\nqcstats <- perCellQCMetrics(sce, subsets=list(Mito=is.mito)) # calculate QC metrics \nfiltered <- quickPerCellQC(qcstats, percent_subsets=\"subsets_Mito_percent\") # filter base on QC metrics\nsce <- sce[, !filtered$discard] # subset object for post-QC analyses\n\n# Normalization.\nsce <- logNormCounts(sce)\n\n# Feature selection (which genes are most important)? \nlibrary(scran)\ndec.retina <- modelGeneVar(sce)\nhvg <- getTopHVGs(dec.retina, prop=0.1)\n\n# Visualizing the fit:\nfit.retina <- metadata(dec.retina)\nplot(fit.retina$mean, fit.retina$var, xlab=\"Mean of log-expression\",\n    ylab=\"Variance of log-expression\")\ncurve(fit.retina$trend(x), col=\"dodgerblue\", add=TRUE, lwd=2)\n```\n\n::: {.cell-output-display}\n![](intro-singlecell_files/figure-html/unnamed-chunk-20-1.png){width=672}\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# PCA\nlibrary(scater)\nset.seed(1234)\nsce <- runPCA(sce, ncomponents=25, subset_row=hvg)\n\n# Clustering.\nlibrary(bluster)\ncolLabels(sce) <- clusterCells(sce, use.dimred='PCA',\n    BLUSPARAM=NNGraphParam(cluster.fun=\"louvain\"))  \n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# Visualization of PC1 vs PC2\nplotPCA(sce, colour_by=\"label\")\n```\n\n::: {.cell-output-display}\n![](intro-singlecell_files/figure-html/unnamed-chunk-22-1.png){width=672}\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# UMAP visualization \nsce <- runUMAP(sce, dimred = 'PCA')\nplotUMAP(sce, colour_by=\"label\")\n```\n\n::: {.cell-output-display}\n![UMAP plot of the retina dataset, where each point is a cell and is colored by the assigned cluster identity.](intro-singlecell_files/figure-html/unnamed-chunk-23-1.png){width=672}\n:::\n:::\n\n\n## For more information\n\nIf you could like to know more, check out this book:\n\n- <https://bioconductor.org/books/release/OSCA/>\n\n\n# Part 4\n\nLast, we will briefly highlight the `tidySingleCellExperiment` package (<https://www.bioconductor.org/packages/SingleCellExperiment>) that allows you to leverage functions from `dplyr`, `tidyr`, and `ggplot2` with a `SingleCellExperiment` object. \n\nThis package is part of a large set of packages called `tidyomics`, which bridges the two worlds of tidy principles in R with Bioconductor. \n\nIt is similar to `tidyverse` in that it installs a series of packages that are designed to work with different types of objects in Bioconductor. \nSpecifically, it installs: \n\n- `plyranges` = for data with `GRanges`\n- `tidybulk` = for bulk RNA-sequencing data \n- `tidySummarizedExperiment` = for data in a `SummarizedExperiment` object\n- `tidySingleCellExperiment` = for data in a `SingleCellExperiment` object\n- `tidySpatialExperiment` = for data in a `SpatialExperiment` object\n- `tidyseurat` = to bring Seurat to the tidyverse \n- `nullranges` = to generate of sets of `GRranges` representing the null hypothesis\n\n\nFor more information: \n\n- manuscript: <https://doi.org/10.1101/2023.09.10.557072>\n- to install `tidyomics`: <https://github.com/tidyomics/tidyomics>\n\n``` r \nremotes::install_github(\"tidyomics/tidyomics\")\n```\n\n\n## Overview \n\n::: {.cell}\n\n```{.r .cell-code}\nsuppressPackageStartupMessages({\n  library(tidySummarizedExperiment) # allow dplyr\n})\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nsce |>\n  addPerCellQC(subsets=list(Mito=is.mito)) |>\n  colData()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nDataFrame with 45877 rows and 10 columns\n                        cell.id   cluster sizeFactor    label       sum\n                    <character> <integer>  <numeric> <factor> <numeric>\nr1_GGCCGCAGTCCG r1_GGCCGCAGTCCG         2    28.0131        1     37487\nr1_CTTGTGCGGGAA r1_CTTGTGCGGGAA         2    23.9479        1     32047\nr1_GCGCAACTGCTC r1_GCGCAACTGCTC         2    21.0343        1     28148\nr1_GATTGGGAGGCA r1_GATTGGGAGGCA         2    15.2197        1     20367\nr1_CCTCCTAGTTGG r1_CCTCCTAGTTGG        NA    14.6167        1     19560\n...                         ...       ...        ...      ...       ...\np1_TCAAAAGCCGGG p1_TCAAAAGCCGGG        24   0.610523       13       817\np1_ATTAAGTTCCAA p1_ATTAAGTTCCAA        34   0.610523       5        817\np1_CTGTCTGAGACC p1_CTGTCTGAGACC         2   0.610523       1        817\np1_TAACGCGCTCCT p1_TAACGCGCTCCT        24   0.609776       11       816\np1_ATTCTTGTTCTT p1_ATTCTTGTTCTT        24   0.609776       8        816\n                 detected subsets_Mito_sum subsets_Mito_detected\n                <integer>        <numeric>             <integer>\nr1_GGCCGCAGTCCG      7243              427                    14\nr1_CTTGTGCGGGAA      6933              503                    15\nr1_GCGCAACTGCTC      6397              460                    13\nr1_GATTGGGAGGCA      5740              326                    11\nr1_CCTCCTAGTTGG      5779              264                     9\n...                   ...              ...                   ...\np1_TCAAAAGCCGGG       537               13                     4\np1_ATTAAGTTCCAA       574               10                     5\np1_CTGTCTGAGACC       637               24                     7\np1_TAACGCGCTCCT       488               27                     5\np1_ATTCTTGTTCTT       484               16                     4\n                subsets_Mito_percent     total\n                           <numeric> <numeric>\nr1_GGCCGCAGTCCG              1.13906     37487\nr1_CTTGTGCGGGAA              1.56957     32047\nr1_GCGCAACTGCTC              1.63422     28148\nr1_GATTGGGAGGCA              1.60063     20367\nr1_CCTCCTAGTTGG              1.34969     19560\n...                              ...       ...\np1_TCAAAAGCCGGG              1.59119       817\np1_ATTAAGTTCCAA              1.22399       817\np1_CTGTCTGAGACC              2.93758       817\np1_TAACGCGCTCCT              3.30882       816\np1_ATTCTTGTTCTT              1.96078       816\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# Identify variable genes with scran\nvariable_genes <-\n    sce %>%\n    modelGeneVar() %>%\n    getTopHVGs(prop=0.1)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# Perform PCA with scater\nretina_pca <-\n    sce %>%\n    runPCA(subset_row=variable_genes)\n\nplotPCA(retina_pca, colour_by=\"label\")\n```\n\n::: {.cell-output-display}\n![](intro-singlecell_files/figure-html/unnamed-chunk-27-1.png){width=672}\n:::\n:::\n\n\n\n# Session Info\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsessionInfo()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nR version 4.3.1 (2023-06-16)\nPlatform: aarch64-apple-darwin20 (64-bit)\nRunning under: macOS Ventura 13.4.1\n\nMatrix products: default\nBLAS:   /Library/Frameworks/R.framework/Versions/4.3-arm64/Resources/lib/libRblas.0.dylib \nLAPACK: /Library/Frameworks/R.framework/Versions/4.3-arm64/Resources/lib/libRlapack.dylib;  LAPACK version 3.11.0\n\nlocale:\n[1] en_US.UTF-8/en_US.UTF-8/en_US.UTF-8/C/en_US.UTF-8/en_US.UTF-8\n\ntime zone: America/New_York\ntzcode source: internal\n\nattached base packages:\n[1] stats4    stats     graphics  grDevices utils     datasets  methods  \n[8] base     \n\nother attached packages:\n [1] tidySummarizedExperiment_1.10.0 bluster_1.10.0                 \n [3] scran_1.28.2                    scater_1.28.0                  \n [5] scuttle_1.9.4                   scRNAseq_2.14.0                \n [7] SingleCellExperiment_1.22.0     SummarizedExperiment_1.30.2    \n [9] Biobase_2.60.0                  GenomicRanges_1.52.0           \n[11] GenomeInfoDb_1.36.3             IRanges_2.34.1                 \n[13] S4Vectors_0.38.1                BiocGenerics_0.46.0            \n[15] MatrixGenerics_1.12.3           matrixStats_1.0.0              \n[17] dplyr_1.1.3                     ggplot2_3.4.3                  \n[19] palmerpenguins_0.1.1           \n\nloaded via a namespace (and not attached):\n  [1] rstudioapi_0.15.0             jsonlite_1.8.7               \n  [3] magrittr_2.0.3                ggbeeswarm_0.7.2             \n  [5] GenomicFeatures_1.52.2        farver_2.1.1                 \n  [7] rmarkdown_2.24                BiocIO_1.10.0                \n  [9] zlibbioc_1.46.0               vctrs_0.6.3                  \n [11] memoise_2.0.1                 Rsamtools_2.16.0             \n [13] DelayedMatrixStats_1.22.6     RCurl_1.98-1.12              \n [15] htmltools_0.5.6               S4Arrays_1.0.6               \n [17] progress_1.2.2                AnnotationHub_3.8.0          \n [19] curl_5.0.2                    BiocNeighbors_1.18.0         \n [21] htmlwidgets_1.6.2             plotly_4.10.2                \n [23] cachem_1.0.8                  GenomicAlignments_1.36.0     \n [25] igraph_1.5.1                  mime_0.12                    \n [27] lifecycle_1.0.3               pkgconfig_2.0.3              \n [29] rsvd_1.0.5                    Matrix_1.6-1                 \n [31] R6_2.5.1                      fastmap_1.1.1                \n [33] GenomeInfoDbData_1.2.10       shiny_1.7.5                  \n [35] digest_0.6.33                 colorspace_2.1-0             \n [37] AnnotationDbi_1.62.2          dqrng_0.3.1                  \n [39] irlba_2.3.5.1                 ExperimentHub_2.8.1          \n [41] RSQLite_2.3.1                 beachmat_2.16.0              \n [43] filelock_1.0.2                labeling_0.4.3               \n [45] fansi_1.0.4                   httr_1.4.7                   \n [47] abind_1.4-5                   compiler_4.3.1               \n [49] bit64_4.0.5                   withr_2.5.0                  \n [51] BiocParallel_1.34.2           viridis_0.6.4                \n [53] DBI_1.1.3                     biomaRt_2.56.1               \n [55] rappdirs_0.3.3                DelayedArray_0.26.7          \n [57] rjson_0.2.21                  tools_4.3.1                  \n [59] vipor_0.4.5                   beeswarm_0.4.0               \n [61] interactiveDisplayBase_1.38.0 httpuv_1.6.11                \n [63] glue_1.6.2                    restfulr_0.0.15              \n [65] promises_1.2.1                grid_4.3.1                   \n [67] cluster_2.1.4                 generics_0.1.3               \n [69] gtable_0.3.4                  tidyr_1.3.0                  \n [71] ensembldb_2.24.0              data.table_1.14.8            \n [73] hms_1.1.3                     metapod_1.7.0                \n [75] BiocSingular_1.16.0           ScaledMatrix_1.8.1           \n [77] xml2_1.3.5                    utf8_1.2.3                   \n [79] XVector_0.40.0                RcppAnnoy_0.0.21             \n [81] ggrepel_0.9.3                 BiocVersion_3.17.1           \n [83] pillar_1.9.0                  stringr_1.5.0                \n [85] limma_3.56.2                  later_1.3.1                  \n [87] BiocFileCache_2.8.0           lattice_0.21-8               \n [89] rtracklayer_1.60.1            bit_4.0.5                    \n [91] tidyselect_1.2.0              locfit_1.5-9.8               \n [93] Biostrings_2.68.1             knitr_1.44                   \n [95] gridExtra_2.3                 ProtGenerics_1.32.0          \n [97] edgeR_3.42.4                  xfun_0.40                    \n [99] statmod_1.5.0                 stringi_1.7.12               \n[101] lazyeval_0.2.2                yaml_2.3.7                   \n[103] evaluate_0.21                 codetools_0.2-19             \n[105] tibble_3.2.1                  BiocManager_1.30.22          \n[107] cli_3.6.1                     uwot_0.1.16                  \n[109] xtable_1.8-4                  munsell_0.5.0                \n[111] Rcpp_1.0.11                   dbplyr_2.3.3                 \n[113] png_0.1-8                     XML_3.99-0.14                \n[115] parallel_4.3.1                ellipsis_0.3.2               \n[117] blob_1.2.4                    prettyunits_1.1.1            \n[119] AnnotationFilter_1.24.0       sparseMatrixStats_1.12.2     \n[121] bitops_1.0-7                  viridisLite_0.4.2            \n[123] scales_1.2.1                  purrr_1.0.2                  \n[125] crayon_1.5.2                  rlang_1.1.1                  \n[127] KEGGREST_1.40.0              \n```\n:::\n:::\n",
    "supporting": [
      "intro-singlecell_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}