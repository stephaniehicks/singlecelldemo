[
  {
    "objectID": "intro-bioc.html",
    "href": "intro-bioc.html",
    "title": "Introduction to Bioconductor",
    "section": "",
    "text": "Workshop material: pkgdown website\nCode: GitHub\n\n\n\n\n\nDescribe what is the Bioconductor and how it’s different than CRAN\nDescribe the package types in Bioconductor\nRecognize and work with core Bioconductor objects including SummarizedExperiment\nBe able to perform a basic differential expression analysis with bulk RNA-seq\nIntroduce the core Bioconductor object called SingleCellExperiment."
  },
  {
    "objectID": "intro-bioc.html#key-resources",
    "href": "intro-bioc.html#key-resources",
    "title": "Introduction to Bioconductor",
    "section": "",
    "text": "Workshop material: pkgdown website\nCode: GitHub"
  },
  {
    "objectID": "intro-bioc.html#learning-objectives",
    "href": "intro-bioc.html#learning-objectives",
    "title": "Introduction to Bioconductor",
    "section": "",
    "text": "Describe what is the Bioconductor and how it’s different than CRAN\nDescribe the package types in Bioconductor\nRecognize and work with core Bioconductor objects including SummarizedExperiment\nBe able to perform a basic differential expression analysis with bulk RNA-seq\nIntroduce the core Bioconductor object called SingleCellExperiment."
  },
  {
    "objectID": "intro-bioc.html#a-brief-history-of-bioconductor",
    "href": "intro-bioc.html#a-brief-history-of-bioconductor",
    "title": "Introduction to Bioconductor",
    "section": "A brief history of Bioconductor",
    "text": "A brief history of Bioconductor\nThe Bioconductor project was started in the Fall of 2001, as an initiative for the collaborative creation of extensible software for computational biology and bioinformatics.\nThe goal of the project is to develop tools for the statistical analysis and comprehension of large datasets and technological artifacts in rigorously and robustly designed experiments. Beyond statistical analyses, the interpretation of statistical results is supported by packages providing biological context, visualization, and reproducibility.\nOver the years, software packages contributed to the Bioconductor project have reflected the evolution and emergence of several high-throughput technologies, from microarrays to single-cell genomics, through many variations of sequencing experiments (e.g., RNA-seq, ChIP-seq, DNA-seq), analyses (e.g., sequence variation, copy number variation, single nucleotide polymorphisms), and data modalities (e.g., flow cytometry, proteomics, microscropy and image analysis).\nThe Bioconductor project culminates at an annual conference in North America in the summer, while regional conferences offer great opportunities for networking in Europe, Asia, and North America.\nThe project is committed to promote a diverse and inclusive community, including a Code of Conduct enforced by a Code of Conduct committee.\n\n\n\nTimeline of major Bioconductor milestones alongside technological advancements.\n\n\nTimeline of major Bioconductor milestones alongside technological advancements. Above the timeline, the figure marks the first occurrence of major events. Within the timeline, the name of packages providing core infrastructure indicate the release date. Below the timeline, major technological advancements contextualise the evolution of the Bioconductor project over time."
  },
  {
    "objectID": "intro-bioc.html#a-scientific-project",
    "href": "intro-bioc.html#a-scientific-project",
    "title": "Introduction to Bioconductor",
    "section": "A scientific project",
    "text": "A scientific project\n\nThe original publication describes the aims and methods of the project at its inception is Gentleman et al. (2004).\nHuber et al. (2015) illustrates the progression of the project, including descriptions of core infrastructure and case studies, from the perspective of both users and developers.\nAmezquita et al. (2020) reviewed further developments of the project in the wake of single-cell genomics technologies.\n\nMany more publications and book chapters cite the Bioconductor project, with recent example listed on the Bioconductor website.\nIn addition, there is a core team which is supported by an NIH grant, and developers who contribute to the open source Bioconductor packages."
  },
  {
    "objectID": "intro-bioc.html#a-package-repository",
    "href": "intro-bioc.html#a-package-repository",
    "title": "Introduction to Bioconductor",
    "section": "A package repository",
    "text": "A package repository"
  },
  {
    "objectID": "intro-bioc.html#overview-and-relationship-to-cran",
    "href": "intro-bioc.html#overview-and-relationship-to-cran",
    "title": "Introduction to Bioconductor",
    "section": "Overview and relationship to CRAN",
    "text": "Overview and relationship to CRAN\nUndoubtedly, software packages are the best-known aspect of the Bioconductor project. Since its inception in 2001, the repository has grown over time to host thousands of packages.\nThe Bioconductor project has extended the preexisting CRAN repository – much larger and general-purpose in scope – to comprise R packages primarily catering for bioinformatics and computational biology analyses."
  },
  {
    "objectID": "intro-bioc.html#the-bioconductor-release-cycle",
    "href": "intro-bioc.html#the-bioconductor-release-cycle",
    "title": "Introduction to Bioconductor",
    "section": "The Bioconductor release cycle",
    "text": "The Bioconductor release cycle\nThe Bioconductor project also extended the packaging infrastructure of the CRAN repository to better support the deployment and management of packages at the user level.\nIn particular, the Bioconductor projects features a 6-month release cycle (typically around April and October), which sees a snapshot of the current version of all packages in the Bioconductor repository earmarked for a specific version of R.\nR itself is released on an annual basis (typically around April), meaning that for each release of R, two compatible releases of Bioconductor packages are available.\n\nAs such, Bioconductor package developers are required to always use the version of R that will be associated with the next release of the Bioconductor project.\nThis means using the development version of R between October and April, and the release version of R between April and October.\n\nWhy? The strict Bioconductor release cycle prevents users from installing temporally distant versions of packages that were very likely never tested together.\nThis practice reflects the development cycle of packages of both CRAN and Bioconductor, where contemporaneous packages are regularly tested by automated systems to ensure that the latest software updates in package dependencies do not break downstream packages, or prompts those package maintainers to update their own software as a consequence.\nPrior to each Bioconductor release, packages that do not pass the requires suites of automated tests are deprecated and subsequently removed from the repository.\nThis ensures that each Bioconductor release provides a suite of packages that are mutually compatible, traceable, and guaranteed to function for the associated version of R.\n\n\n\nTimeline of release dates for selected Bioconductor and R versions.\n\n\nTimeline of release dates for selected Bioconductor and R versions. The upper section of the timeline indicates versions and approximate release dates for the R project. The lower section of the timeline indicates versions and release dates for the Bioconductor project. Source: Bioconductor."
  },
  {
    "objectID": "intro-bioc.html#package-types",
    "href": "intro-bioc.html#package-types",
    "title": "Introduction to Bioconductor",
    "section": "Package types",
    "text": "Package types\nPackages are broadly divided in four major categories:\n\nsoftware\nannotation data\nexperiment data\nworkflows\n\nSoftware packages themselves can be subdivided into packages that\n\nprovide infrastructure (i.e., classes) to store and access data\npackages that provide methodological tools to process data stored in those data structures\n\nThis separation of structure and analysis is at the core of the Bioconductor project, encouraging developers of new methodological software packages to thoughtfully re-use existing data containers where possible, and reducing the cognitive burden imposed on users who can more easily experiment with alternative workflows without the need to learn and convert between different data structures.\nAnnotation data packages provide self-contained databases of diverse genomic annotations (e.g., gene identifiers, biological pathways).\n\nDifferent collections of annotation packages can be found in the Bioconductor project.\nThey are identifiable by their respective naming pattern, and the information that they contain.\n\nFor instance, the so-called OrgDb packages (e.g., the org.Hs.eg.db package) provide information mapping different types of gene identifiers and pathway databases; the so-called EnsDb (e.g., EnsDb.Hsapiens.v86) packages encapsulate individual versions of the Ensembl annotations in Bioconductor packages; and the so-called TxDb packages (e.g., TxDb.Hsapiens.UCSC.hg38.knownGene) encapsulate individual versions UCSC gene annotation tables.\nExperiment data packages provide self-contained datasets that are often used by software package developers to demonstrate the use of their package on well-known standard datasets in their package vignettes.\nFinally, workflow packages exclusively provide collections of vignettes that demonstrate the combined usage of several other packages as a coherent workflow, but do not provide any new source code or functionality themselves."
  },
  {
    "objectID": "intro-bioc.html#online-communication-channels",
    "href": "intro-bioc.html#online-communication-channels",
    "title": "Introduction to Bioconductor",
    "section": "Online communication channels",
    "text": "Online communication channels\n\nSupport site\nThe Bioconductor support site provides a platform where users and developers can communicate freely (following the Bioconductor Code of Conduct) to discuss issues on a range of subjects, ranging from packages to conceptual questions about best practices.\n\n\nSlack workspace\nThe Bioconductor Slack workspace is an open space that all community members are welcome to join (for free) and use for rapid interactions. Currently, the “Pro” pricing plan kindly supported by core funding provides:\n\nUnlimited message archive\nUnlimited apps\nGroup video calls with screen sharing\nWork securely with other organizations using Slack Connect\n\nA wide range of channels have been created to discuss a range of subjects, and community members can freely join the discussion on those channels of create new ones to discuss new subjects.\nImportant announcements are posted on the #general channel.\n\n\nDeveloper Mailing List\nThe bioc-devel@r-project.org mailing list is used for communication between package developers, and announcements from the Biocondutor core team.\n\n\nA scientific and technical community\n\nScientific Advisory Board (SAB) Meet Annually, External and Internal leader in the field who act as project advisors. No Term limits.\nTechnical Advisory Board (TAB). Meet monthly to consider technical aspects of core infastructure and scientific direction of the project. 15 members, 3 year term. Annual open-to-all elections to rotate members. Current officers are Vince Carey (chair), Levi Waldron (vice Chair) Charlotte Soneson (Secretary).\nCommunity Advisory Board (CAB) Meet monthly to consider community outreach, events, education and training. 15 members, 3 year term. Annual open-to-all elections to rotate members. Current officers are Aedin Culhane (chair), Matt Ritchie (co Chair), Lori Kern (Secretary).\nCode of Conduct committee"
  },
  {
    "objectID": "intro-bioc.html#working-with-bioconductor-objects",
    "href": "intro-bioc.html#working-with-bioconductor-objects",
    "title": "Introduction to Bioconductor",
    "section": "Working with Bioconductor objects",
    "text": "Working with Bioconductor objects\nBioconductor’s infrastructure is built up of object classes.\nAn example of a class is GRanges (stands for “genomic ranges”), which is a way to specify a set of ranges in a particular genome, e.g. from basepair 101 to basepair 200 on chromosome 1 of the human genome (version 38).\nWhat’s an object?\nWell everything in R is an object, but usually when we talk about Bioconductor objects, we mean data structures containing many attributes, so more complex than a vector or matrix.\nAnd the objects have specific methods that help you either access the information in the object, run analyses on the object, plot the object, etc.\nBioconductor also allows for class hierarchy, which means that you can define a class of object that inherits the structure and methods of a superclass on which it depends. This last point is mostly important for people who are developing new software for Bioconductor (maybe that’s you!)\nWe will introduce the core Bioconductor objects here.\n\nSummarizedExperiment (SE)\nFirst, we will discuss one of the most important classes of object, which is the SummarizedExperiment, or SE.\nSEs have the structure:\n\na matrix of data, rows are genomic features, and columns are samples\na table of data about the samples (columns)\na table of data about the features (rows)\n\nA diagram of this 3-part structure can be found here.\nIn SE, the 3 parts of the object are called 1) assay, 2) colData and 3) rowData or rowRanges.\nNote: There was a class of object that came before the SE, called the ExpressionSet, which was used primarily to store microarray data.\nHere we will skip over the ExpressionSet, and just look at SEs.\nIt helps to start by making a small toy SE, to see how the pieces come together. (Often you won’t make an SE manually, but it will be downloaded from an external source, or generated by a function that you call, e.g. the tximeta or some other data loading function.)\n\nlibrary(SummarizedExperiment)\ncol_data &lt;- data.frame(sample=factor(1:6),\n                       condition=factor(c(\"A\",\"A\",\"B\",\"B\",\"C\",\"C\")),\n                       treated=factor(rep(0:1,3)))\ncol_data\n\n  sample condition treated\n1      1         A       0\n2      2         A       1\n3      3         B       0\n4      4         B       1\n5      5         C       0\n6      6         C       1\n\n\nAn important aspect of SEs is that the rows can optionally correspond to particular set of GRanges\n\ne.g. a row of an SE could give the number of RNA-seq reads that can be assigned to a particular gene, and the row could also have metadata in the 3rd slot including, e.g. location of the gene in the genome.\n\nIn this case, we use the rowRanges slot to specify the information.\nIf we don’t have ranges, we can just put a table on the “side” of the SE by specifying rowData.\nI will show in the example though how to provide rowRanges.\nLet’s use the first 10 genes in the Ensembl database for human.\nThe following code loads a database, pulls out all the genes (as GRanges), removes extra “non-standard” chromosomes, and then subsets to the first 10 genes.\n\nlibrary(EnsDb.Hsapiens.v86)\ntxdb &lt;- EnsDb.Hsapiens.v86\ng &lt;- genes(txdb)\ng &lt;- keepStandardChromosomes(g, pruning.mode=\"coarse\")\nrow_ranges &lt;- g[1:10]\n\nWe will make up some simulated “expression” measurements, and then store these in the SE.\nI call list so I can name the matrix, otherwise it would not be named.\n\nexprs &lt;- matrix(rnorm(6 * 10), ncol=6, nrow=10)\nse &lt;- SummarizedExperiment(assay = list(\"exprs\" = exprs),\n                           colData = col_data,\n                           rowRanges = row_ranges)\nse\n\nclass: RangedSummarizedExperiment \ndim: 10 6 \nmetadata(0):\nassays(1): exprs\nrownames(10): ENSG00000223972 ENSG00000227232 ... ENSG00000238009\n  ENSG00000239945\nrowData names(6): gene_id gene_name ... symbol entrezid\ncolnames: NULL\ncolData names(3): sample condition treated\n\n\nWe see this object has one named matrix. The object could have multiple matrices (as long as these are the same shape).\nIn that case you could access the first with assay and in general by name, e.g. assay(se, \"exprs\") or equivalently assays(se)[[\"exprs\"]] .\n\nassayNames(se)\n\n[1] \"exprs\"\n\n\nFinally, if we wanted to add data onto the rows, for example, the score of a test on the matrix data, we use the metadata columns function, or mcols:\n\nmcols(se)$score &lt;- rnorm(10)\nmcols(se)\n\nDataFrame with 10 rows and 7 columns\n                        gene_id    gene_name           gene_biotype\n                    &lt;character&gt;  &lt;character&gt;            &lt;character&gt;\nENSG00000223972 ENSG00000223972      DDX11L1 transcribed_unproces..\nENSG00000227232 ENSG00000227232       WASH7P unprocessed_pseudogene\nENSG00000278267 ENSG00000278267    MIR6859-1                  miRNA\nENSG00000243485 ENSG00000243485    MIR1302-2                lincRNA\nENSG00000237613 ENSG00000237613      FAM138A                lincRNA\nENSG00000268020 ENSG00000268020       OR4G4P unprocessed_pseudogene\nENSG00000240361 ENSG00000240361      OR4G11P unprocessed_pseudogene\nENSG00000186092 ENSG00000186092        OR4F5         protein_coding\nENSG00000238009 ENSG00000238009 RP11-34P13.7                lincRNA\nENSG00000239945 ENSG00000239945 RP11-34P13.8                lincRNA\n                seq_coord_system       symbol                       entrezid\n                     &lt;character&gt;  &lt;character&gt;                         &lt;list&gt;\nENSG00000223972       chromosome      DDX11L1 100287596,100287102,727856,...\nENSG00000227232       chromosome       WASH7P                             NA\nENSG00000278267       chromosome    MIR6859-1                      102466751\nENSG00000243485       chromosome    MIR1302-2            105376912,100302278\nENSG00000237613       chromosome      FAM138A           654835,645520,641702\nENSG00000268020       chromosome       OR4G4P                             NA\nENSG00000240361       chromosome      OR4G11P                             NA\nENSG00000186092       chromosome        OR4F5                          79501\nENSG00000238009       chromosome RP11-34P13.7                             NA\nENSG00000239945       chromosome RP11-34P13.8                             NA\n                      score\n                  &lt;numeric&gt;\nENSG00000223972  0.77412990\nENSG00000227232  1.91960801\nENSG00000278267  0.74997304\nENSG00000243485  0.07382010\nENSG00000237613  0.14684242\nENSG00000268020 -0.61621410\nENSG00000240361 -0.35452656\nENSG00000186092  0.00321142\nENSG00000238009  0.86520890\nENSG00000239945  0.71432373\n\n\nAdding data to the column metadata is even easier, we can just use $:\n\nse$librarySize &lt;- runif(6,1e6,2e6)\ncolData(se)\n\nDataFrame with 6 rows and 4 columns\n    sample condition  treated librarySize\n  &lt;factor&gt;  &lt;factor&gt; &lt;factor&gt;   &lt;numeric&gt;\n1        1         A        0     1100362\n2        2         A        1     1461149\n3        3         B        0     1465337\n4        4         B        1     1557165\n5        5         C        0     1991141\n6        6         C        1     1564061\n\n\n\n\nUsing the ranges of a SE\nHow does this additional functionality of the rowRanges facilitate faster data analysis?\nSuppose we are working with another data set besides se and we find a region of interest on chromsome 1.\nIf we want to pull out the expression data for that region, we just ask for the subset of se that overlaps.\nFirst, we build the query region, and then use the GRanges function overlapsAny() within single square brackets (like you would subset any matrix-like object):\n\nquery &lt;- GRanges(\"1\", IRanges(25000,40000))\nse_sub &lt;- se[overlapsAny(se, query), ]\n\nWe could have equivalently used the shorthand code:\n\nse_sub &lt;- se[se %over% query,]\n\nWe get just three ranges, and three rows of the SE:\n\nrowRanges(se_sub)\n\nGRanges object with 3 ranges and 7 metadata columns:\n                  seqnames      ranges strand |         gene_id   gene_name\n                     &lt;Rle&gt;   &lt;IRanges&gt;  &lt;Rle&gt; |     &lt;character&gt; &lt;character&gt;\n  ENSG00000227232        1 14404-29570      - | ENSG00000227232      WASH7P\n  ENSG00000243485        1 29554-31109      + | ENSG00000243485   MIR1302-2\n  ENSG00000237613        1 34554-36081      - | ENSG00000237613     FAM138A\n                            gene_biotype seq_coord_system      symbol\n                             &lt;character&gt;      &lt;character&gt; &lt;character&gt;\n  ENSG00000227232 unprocessed_pseudogene       chromosome      WASH7P\n  ENSG00000243485                lincRNA       chromosome   MIR1302-2\n  ENSG00000237613                lincRNA       chromosome     FAM138A\n                              entrezid     score\n                                &lt;list&gt; &lt;numeric&gt;\n  ENSG00000227232                 &lt;NA&gt; 1.9196080\n  ENSG00000243485  105376912,100302278 0.0738201\n  ENSG00000237613 654835,645520,641702 0.1468424\n  -------\n  seqinfo: 25 sequences (1 circular) from GRCh38 genome\n\nassay(se_sub)\n\n                       [,1]         [,2]       [,3]       [,4]       [,5]\nENSG00000227232 -1.06373465 -1.609629509 -0.2733834 0.02636937  0.6989656\nENSG00000243485 -0.32590415 -0.397960499  0.4548816 1.34134627  1.1925366\nENSG00000237613  0.06361643 -0.001326981  1.1687272 0.53832418 -0.3989560\n                      [,6]\nENSG00000227232 -0.1839018\nENSG00000243485  0.6173870\nENSG00000237613 -0.7565909\n\n\nAnother useful property is that we know metadata about the chromosomes, and the version of the genome.\n\nNote: If you were not yet aware, the basepair position of a given feature, say gene XYZ, will change between versions of the genome, as sequences are added or rearranged.\n\n\nseqinfo(se)\n\nSeqinfo object with 25 sequences (1 circular) from GRCh38 genome:\n  seqnames seqlengths isCircular genome\n  1         248956422      FALSE GRCh38\n  10        133797422      FALSE GRCh38\n  11        135086622      FALSE GRCh38\n  12        133275309      FALSE GRCh38\n  13        114364328      FALSE GRCh38\n  ...             ...        ...    ...\n  8         145138636      FALSE GRCh38\n  9         138394717      FALSE GRCh38\n  MT            16569       TRUE GRCh38\n  X         156040895      FALSE GRCh38\n  Y          57227415      FALSE GRCh38"
  },
  {
    "objectID": "intro-bioc.html#downloading-se-data",
    "href": "intro-bioc.html#downloading-se-data",
    "title": "Introduction to Bioconductor",
    "section": "Downloading SE data",
    "text": "Downloading SE data\nLet’s download a SE object from recount2, which performs a basic summarization of public data sets with gene expression data.\nThis dataset contains RNA-seq samples from human airway epithelial cell cultures.\nThe paper is here. The structure of the experiment was that, cell cultures from 6 asthmatic and 6 non-asthmatics donors were treated with viral infection or left untreated (controls).\nSo we have 2 samples (control or treated) for each of the 12 donors.\n\nlibrary(here)\n\nhere() starts at /Users/stephaniehicks/Documents/github/projects/singlecelldemo\n\n# tests if a directory named \"data\" exists locally\nif(!dir.exists(here(\"data\"))) { dir.create(here(\"data\")) }\n\nfile &lt;- \"asthma.rda\"\nif (!file.exists(here(\"data\", file))){\n  url &lt;- \"http://duffel.rail.bio/recount/SRP046226/rse_gene.Rdata\"\n  download.file(url, here(\"data\", file))\n}\nload(here(\"data\", file))\n\nWe use a custom function to produce a matrix which a count of RNA fragments for each gene (rows) and each sample (columns).\n(Recount project calls these objects rse for RangedSummarizedExperiment, meaning it has rowRanges information.)\n\nmy_scale_counts &lt;- function(rse_gene, round=TRUE) {\n  cts &lt;- assays(rse_gene)$counts\n  # mapped_read_count includes the count for both reads of a pair\n  paired &lt;- ifelse(colData(rse_gene)$paired_end, 2, 1)\n  x &lt;- (colData(rse_gene)$mapped_read_count / paired) / colSums(cts)\n  assays(rse_gene)$counts &lt;- t(t(assays(rse_gene)$counts) * x)\n  if (round) {\n    assays(rse_gene)$counts &lt;- round(assays(rse_gene)$counts)\n  }\n  rse_gene\n}\n\nrse &lt;- my_scale_counts(rse_gene)\n\nWe can take a peek at the column data:\n\ncolData(rse)[,1:6]\n\nDataFrame with 24 rows and 6 columns\n               project      sample  experiment         run\n           &lt;character&gt; &lt;character&gt; &lt;character&gt; &lt;character&gt;\nSRR1565926   SRP046226   SRS694613   SRX692912  SRR1565926\nSRR1565927   SRP046226   SRS694614   SRX692913  SRR1565927\nSRR1565928   SRP046226   SRS694615   SRX692914  SRR1565928\nSRR1565929   SRP046226   SRS694616   SRX692915  SRR1565929\nSRR1565930   SRP046226   SRS694617   SRX692916  SRR1565930\n...                ...         ...         ...         ...\nSRR1565945   SRP046226   SRS694632   SRX692931  SRR1565945\nSRR1565946   SRP046226   SRS694633   SRX692932  SRR1565946\nSRR1565947   SRP046226   SRS694634   SRX692933  SRR1565947\nSRR1565948   SRP046226   SRS694635   SRX692934  SRR1565948\nSRR1565949   SRP046226   SRS694636   SRX692935  SRR1565949\n           read_count_as_reported_by_sra reads_downloaded\n                               &lt;integer&gt;        &lt;integer&gt;\nSRR1565926                      12866750         12866750\nSRR1565927                      12797108         12797108\nSRR1565928                      13319016         13319016\nSRR1565929                      13725752         13725752\nSRR1565930                      10882416         10882416\n...                                  ...              ...\nSRR1565945                      13791854         13791854\nSRR1565946                      13480842         13480842\nSRR1565947                      13166594         13166594\nSRR1565948                      13320398         13320398\nSRR1565949                      13002276         13002276\n\n\nThe information we are interested in is contained in the characteristics column (which is a character list).\n\nclass(rse$characteristics)\n\n[1] \"CompressedCharacterList\"\nattr(,\"package\")\n[1] \"IRanges\"\n\nrse$characteristics[1:3]\n\nCharacterList of length 3\n[[1]] cell type: Isolated from human trachea-bronchial tissues ...\n[[2]] cell type: Isolated from human trachea-bronchial tissues ...\n[[3]] cell type: Isolated from human trachea-bronchial tissues ...\n\nrse$characteristics[[1]]\n\n[1] \"cell type: Isolated from human trachea-bronchial tissues\"\n[2] \"passages: 2\"                                             \n[3] \"disease state: asthmatic\"                                \n[4] \"treatment: HRV16\"                                        \n\n\nWe can pull out the 3 and 4 element using the sapply function and the square bracket function.\nI know this syntax looks a little funny, but it’s really just saying, use the single square bracket, pull out the third element (or fourth element).\n\nrse$condition &lt;- sapply(rse$characteristics, `[`, 3)\nrse$treatment &lt;- sapply(rse$characteristics, `[`, 4)\ntable(rse$condition, rse$treatment)\n\n                              \n                               treatment: HRV16 treatment: Vehicle\n  disease state: asthmatic                    6                  6\n  disease state: non-asthmatic                6                  6\n\n\nLet’s see what the rowRanges of this experiment look like:\n\nrowRanges(rse)\n\nGRanges object with 58037 ranges and 3 metadata columns:\n                     seqnames              ranges strand |            gene_id\n                        &lt;Rle&gt;           &lt;IRanges&gt;  &lt;Rle&gt; |        &lt;character&gt;\n  ENSG00000000003.14     chrX 100627109-100639991      - | ENSG00000000003.14\n   ENSG00000000005.5     chrX 100584802-100599885      + |  ENSG00000000005.5\n  ENSG00000000419.12    chr20   50934867-50958555      - | ENSG00000000419.12\n  ENSG00000000457.13     chr1 169849631-169894267      - | ENSG00000000457.13\n  ENSG00000000460.16     chr1 169662007-169854080      + | ENSG00000000460.16\n                 ...      ...                 ...    ... .                ...\n   ENSG00000283695.1    chr19   52865369-52865429      - |  ENSG00000283695.1\n   ENSG00000283696.1     chr1 161399409-161422424      + |  ENSG00000283696.1\n   ENSG00000283697.1     chrX 149548210-149549852      - |  ENSG00000283697.1\n   ENSG00000283698.1     chr2 112439312-112469687      - |  ENSG00000283698.1\n   ENSG00000283699.1    chr10   12653138-12653197      - |  ENSG00000283699.1\n                     bp_length          symbol\n                     &lt;integer&gt; &lt;CharacterList&gt;\n  ENSG00000000003.14      4535          TSPAN6\n   ENSG00000000005.5      1610            TNMD\n  ENSG00000000419.12      1207            DPM1\n  ENSG00000000457.13      6883           SCYL3\n  ENSG00000000460.16      5967        C1orf112\n                 ...       ...             ...\n   ENSG00000283695.1        61            &lt;NA&gt;\n   ENSG00000283696.1       997            &lt;NA&gt;\n   ENSG00000283697.1      1184    LOC101928917\n   ENSG00000283698.1       940            &lt;NA&gt;\n   ENSG00000283699.1        60         MIR4481\n  -------\n  seqinfo: 25 sequences (1 circular) from an unspecified genome; no seqlengths\n\nseqinfo(rse)\n\nSeqinfo object with 25 sequences (1 circular) from an unspecified genome; no seqlengths:\n  seqnames seqlengths isCircular genome\n  chr1           &lt;NA&gt;       &lt;NA&gt;   &lt;NA&gt;\n  chr2           &lt;NA&gt;       &lt;NA&gt;   &lt;NA&gt;\n  chr3           &lt;NA&gt;       &lt;NA&gt;   &lt;NA&gt;\n  chr4           &lt;NA&gt;       &lt;NA&gt;   &lt;NA&gt;\n  chr5           &lt;NA&gt;       &lt;NA&gt;   &lt;NA&gt;\n  ...             ...        ...    ...\n  chr21          &lt;NA&gt;       &lt;NA&gt;   &lt;NA&gt;\n  chr22          &lt;NA&gt;       &lt;NA&gt;   &lt;NA&gt;\n  chrX           &lt;NA&gt;       &lt;NA&gt;   &lt;NA&gt;\n  chrY           &lt;NA&gt;       &lt;NA&gt;   &lt;NA&gt;\n  chrM           &lt;NA&gt;       TRUE   &lt;NA&gt;\n\n\nThe rowRanges here were determined by the quantification method that the recount2 authors used.\nWe don’t know what the genome is from the seqinfo, but we could look this up from the project website.\nThe following code I use to clean up the condition and treatment variables:\n\nlibrary(magrittr)\nrse$condition %&lt;&gt;% (function(x) {\n  factor(sub(\"-\",\".\", sub(\"disease state: (.*)\",\"\\\\1\",x) ))\n  })\nrse$treatment %&lt;&gt;% (function(x) factor(sub(\"treatment: (.*)\",\"\\\\1\",x)))\n\nNow we have:\n\ntable(rse$condition, rse$treatment)\n\n               \n                HRV16 Vehicle\n  asthmatic         6       6\n  non.asthmatic     6       6"
  },
  {
    "objectID": "intro-bioc.html#visualizing-count-matrix-data-in-a-se",
    "href": "intro-bioc.html#visualizing-count-matrix-data-in-a-se",
    "title": "Introduction to Bioconductor",
    "section": "Visualizing count matrix data in a SE",
    "text": "Visualizing count matrix data in a SE\nHere we just use a transformation so that we can compute meaningful distances on count data (without a larger discussion on normalization).\nWe build a DESeqDataSet and then specify the experimental design using a ~ and the variables that we expect to produce differences in the counts. (These variables are used to assess how much technical variability is in the data, but not used in the transformation function itself.)\n\nlibrary(DESeq2)\ndds &lt;- DESeqDataSet(rse, ~condition + treatment)\n\nconverting counts to integer mode\n\n\nWe use this function, which implements a variance stabilizing transformation:\n\nvsd &lt;- vst(dds)\n\nWe calculate the variance across all samples (on the transformed data):\n\nlibrary(matrixStats)\nrv &lt;- rowVars(assay(vsd))\no &lt;- order(rv, decreasing=TRUE)[1:100]\n\nFinally, before plotting a heatmap, we extract the covariates that we want to annotated the top of the plot.\n\nanno_col &lt;- as.data.frame(colData(vsd)[,c(\"condition\",\"treatment\")])\nanno_col\n\n               condition treatment\nSRR1565926     asthmatic     HRV16\nSRR1565927     asthmatic     HRV16\nSRR1565928     asthmatic     HRV16\nSRR1565929     asthmatic     HRV16\nSRR1565930     asthmatic     HRV16\nSRR1565931     asthmatic     HRV16\nSRR1565932     asthmatic   Vehicle\nSRR1565933     asthmatic   Vehicle\nSRR1565934     asthmatic   Vehicle\nSRR1565935     asthmatic   Vehicle\nSRR1565936     asthmatic   Vehicle\nSRR1565937     asthmatic   Vehicle\nSRR1565938 non.asthmatic     HRV16\nSRR1565939 non.asthmatic     HRV16\nSRR1565940 non.asthmatic     HRV16\nSRR1565941 non.asthmatic     HRV16\nSRR1565942 non.asthmatic     HRV16\nSRR1565943 non.asthmatic     HRV16\nSRR1565944 non.asthmatic   Vehicle\nSRR1565945 non.asthmatic   Vehicle\nSRR1565946 non.asthmatic   Vehicle\nSRR1565947 non.asthmatic   Vehicle\nSRR1565948 non.asthmatic   Vehicle\nSRR1565949 non.asthmatic   Vehicle\n\n\nThis code pull out the top of the transformed data by variance, and adds an annotation to the top of the plot.\nBy default the rows and columns will be clustered by Euclidean distance. See ?pheatmap for more details on this function (it’s a very detailed manual page).\n\nlibrary(pheatmap)\npheatmap(assay(vsd)[o,],\n         annotation_col=anno_col,\n         show_rownames=FALSE, \n         show_colnames=FALSE)\n\n\n\n\nWe can also easily make a PCA plot with dedicated functions:\n\nplotPCA(vsd, intgroup=\"treatment\")"
  },
  {
    "objectID": "intro-granges.html",
    "href": "intro-granges.html",
    "title": "Code from slides",
    "section": "",
    "text": "library(GenomicRanges)\n\nLoading required package: stats4\n\n\nLoading required package: BiocGenerics\n\n\n\nAttaching package: 'BiocGenerics'\n\n\nThe following objects are masked from 'package:stats':\n\n    IQR, mad, sd, var, xtabs\n\n\nThe following objects are masked from 'package:base':\n\n    anyDuplicated, aperm, append, as.data.frame, basename, cbind,\n    colnames, dirname, do.call, duplicated, eval, evalq, Filter, Find,\n    get, grep, grepl, intersect, is.unsorted, lapply, Map, mapply,\n    match, mget, order, paste, pmax, pmax.int, pmin, pmin.int,\n    Position, rank, rbind, Reduce, rownames, sapply, setdiff, sort,\n    table, tapply, union, unique, unsplit, which.max, which.min\n\n\nLoading required package: S4Vectors\n\n\n\nAttaching package: 'S4Vectors'\n\n\nThe following object is masked from 'package:utils':\n\n    findMatches\n\n\nThe following objects are masked from 'package:base':\n\n    expand.grid, I, unname\n\n\nLoading required package: IRanges\n\n\nLoading required package: GenomeInfoDb\n\nlibrary(plyranges)\n\n\nAttaching package: 'plyranges'\n\n\nThe following object is masked from 'package:IRanges':\n\n    slice\n\n\nThe following object is masked from 'package:stats':\n\n    filter\n\ngr &lt;- GRanges(seqnames = \"chr1\", \n              strand = c(\"+\", \"-\"), \n              ranges = IRanges(start = c(102012, 520211), \n                               end = c(120303, 526211)),\n              gene_id = c(1001, 2151), \n              score = c(10, 25))\ngr\n\nGRanges object with 2 ranges and 2 metadata columns:\n      seqnames        ranges strand |   gene_id     score\n         &lt;Rle&gt;     &lt;IRanges&gt;  &lt;Rle&gt; | &lt;numeric&gt; &lt;numeric&gt;\n  [1]     chr1 102012-120303      + |      1001        10\n  [2]     chr1 520211-526211      - |      2151        25\n  -------\n  seqinfo: 1 sequence from an unspecified genome; no seqlengths\n\n\n\nwidth(gr)\n\n[1] 18292  6001\n\ngr[gr$score &gt; 15, ]\n\nGRanges object with 1 range and 2 metadata columns:\n      seqnames        ranges strand |   gene_id     score\n         &lt;Rle&gt;     &lt;IRanges&gt;  &lt;Rle&gt; | &lt;numeric&gt; &lt;numeric&gt;\n  [1]     chr1 520211-526211      - |      2151        25\n  -------\n  seqinfo: 1 sequence from an unspecified genome; no seqlengths\n\n\n\ngr |&gt; \n  filter(score &gt; 15)\n\nGRanges object with 1 range and 2 metadata columns:\n      seqnames        ranges strand |   gene_id     score\n         &lt;Rle&gt;     &lt;IRanges&gt;  &lt;Rle&gt; | &lt;numeric&gt; &lt;numeric&gt;\n  [1]     chr1 520211-526211      - |      2151        25\n  -------\n  seqinfo: 1 sequence from an unspecified genome; no seqlengths\n\ngr |&gt; \n  filter(score &gt; 15) |&gt; \n  width()\n\n[1] 6001\n\n\n\nlibrary(plyranges)\ngr &lt;- \n  data.frame(seqnames = sample(c(\"chr1\", \"chr2\"), 7, replace = TRUE),\n             strand = sample(c(\"+\", \"-\"), 7, replace = TRUE),\n             score = runif(7),\n             start = 1:7,\n             width = 10) %&gt;%\n  as_granges()\ngr\n\nGRanges object with 7 ranges and 1 metadata column:\n      seqnames    ranges strand |     score\n         &lt;Rle&gt; &lt;IRanges&gt;  &lt;Rle&gt; | &lt;numeric&gt;\n  [1]     chr1      1-10      + |  0.519716\n  [2]     chr2      2-11      - |  0.478834\n  [3]     chr1      3-12      - |  0.487161\n  [4]     chr2      4-13      - |  0.677381\n  [5]     chr2      5-14      - |  0.181075\n  [6]     chr1      6-15      - |  0.874615\n  [7]     chr2      7-16      + |  0.615209\n  -------\n  seqinfo: 2 sequences from an unspecified genome; no seqlengths\n\n\n\ngr %&gt;%\n  group_by(strand) %&gt;% \n  summarize(mean_score = mean(score))\n\nDataFrame with 2 rows and 2 columns\n  strand mean_score\n   &lt;Rle&gt;  &lt;numeric&gt;\n1      +   0.567462\n2      -   0.539813"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Introduction to single cell data science",
    "section": "",
    "text": "Advanced Data Science Fall 2023 (140.711) lecture material from Stephanie Hicks."
  },
  {
    "objectID": "index.html#key-resources",
    "href": "index.html#key-resources",
    "title": "Introduction to single cell data science",
    "section": "Key resources",
    "text": "Key resources\n\nLecture material: website\nCode: GitHub"
  },
  {
    "objectID": "index.html#instructor",
    "href": "index.html#instructor",
    "title": "Introduction to single cell data science",
    "section": "Instructor",
    "text": "Instructor\nStephanie C. Hicks, PhD | Associate Professor\nBiostatistics, Johns Hopkins Bloomberg School of Public Health\nFaculty member, Johns Hopkins Data Science Lab\nPronouns: she/her \n\nweb: https://www.stephaniehicks.com\nemail: shicks19@jhu.edu\ntwitter: @stephaniehicks"
  },
  {
    "objectID": "index.html#acknowledgements",
    "href": "index.html#acknowledgements",
    "title": "Introduction to single cell data science",
    "section": "Acknowledgements",
    "text": "Acknowledgements\nThis course website was developed and is maintained by Stephanie C. Hicks.\nThe following individuals have contributed to improving the course or materials have been adapted from their courses:\n\ngist from Mike Love\ntidy genomics talk\nOrchestrating Single-Cell Analysis with Bioconductor (OSCA) contributors (cite: Amezquita et al. 2019)\n\nThe course materials are licensed under the Creative Commons Attribution 4.0 International License. Linked and embedded materials are governed by their own licenses. I assume that all external materials used or embedded here are covered under the educational fair use policy. If this is not the case and any material displayed here violates copyright, please let me know and I will remove it."
  },
  {
    "objectID": "index.html#software",
    "href": "index.html#software",
    "title": "Introduction to single cell data science",
    "section": "Software",
    "text": "Software\nThese materials use tidyverse and packages from Bioconductor version 3.17. This is the current ‘release’ version of Bioconductor, which can be installed following these instructions.\nFor example, you can then install a subset of the packages necessary for these tutorials using the following:\nlibrary(BiocManager)\nBiocManager::install(c(\"SingleCellExperiment\",\"scater\", \"scran\"))"
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "About this site\n\n1 + 1\n\n[1] 2"
  },
  {
    "objectID": "intro-singlecell.html",
    "href": "intro-singlecell.html",
    "title": "Introduction to single cell data science",
    "section": "",
    "text": "Learn what are genomic data and how are they generated?\nWhat is a GRanges object?\nWhat are some advantages of applying tidy principles to genomic data?\nWhat is a SingleCellExperiment object?\n\n\n\n\nWe will go through the slides available here:\n\nhttps://docs.google.com/presentation/d/1VFL4OxK44Q7b1c-Vk9PDnroT-R5_aQP2LRfJaHXQedo/edit?usp=sharing"
  },
  {
    "objectID": "intro-singlecell.html#learning-objectives",
    "href": "intro-singlecell.html#learning-objectives",
    "title": "Introduction to single cell data science",
    "section": "",
    "text": "Learn what are genomic data and how are they generated?\nWhat is a GRanges object?\nWhat are some advantages of applying tidy principles to genomic data?\nWhat is a SingleCellExperiment object?"
  },
  {
    "objectID": "intro-singlecell.html#materials",
    "href": "intro-singlecell.html#materials",
    "title": "Introduction to single cell data science",
    "section": "",
    "text": "We will go through the slides available here:\n\nhttps://docs.google.com/presentation/d/1VFL4OxK44Q7b1c-Vk9PDnroT-R5_aQP2LRfJaHXQedo/edit?usp=sharing"
  },
  {
    "objectID": "intro-singlecell.html#learning-objectives-1",
    "href": "intro-singlecell.html#learning-objectives-1",
    "title": "Introduction to single cell data science",
    "section": "Learning objectives",
    "text": "Learning objectives\n\nRemind ourselves of basics of tidyverse functions (mostly dplyr and ggplot2).\nIntroduce how to preprocess data and to perform principal components analysis (PCA), a widely used method for dimensionality reduction."
  },
  {
    "objectID": "intro-singlecell.html#palmer-penguins",
    "href": "intro-singlecell.html#palmer-penguins",
    "title": "Introduction to single cell data science",
    "section": "Palmer penguins",
    "text": "Palmer penguins\nIn this section, we give an example of using tidyverse functions with the palmerpenguins dataset available as a CRAN package.\n\nlibrary(palmerpenguins) # penguins!\nsuppressPackageStartupMessages({\n  library(ggplot2) # \"grammar of graphics\" plots\n  library(dplyr) # data pliers\n})\n\nWe can select first three rows and two columns:\n\npenguins |&gt; \n  slice(1:3) |&gt;\n  select(species, island) \n\n# A tibble: 3 × 2\n  species island   \n  &lt;fct&gt;   &lt;fct&gt;    \n1 Adelie  Torgersen\n2 Adelie  Torgersen\n3 Adelie  Torgersen\n\n\nAnd estimate the average body mass in grams using summarize():\n\npenguins |&gt; \n  summarize(ave_mass = mean(body_mass_g, na.rm=TRUE))\n\n# A tibble: 1 × 1\n  ave_mass\n     &lt;dbl&gt;\n1    4202.\n\n\nRearranging how we omit NA values, we get the same:\n\npenguins |&gt; \n  na.omit() |&gt; \n  summarize(ave_mass = mean(body_mass_g))\n\n# A tibble: 1 × 1\n  ave_mass\n     &lt;dbl&gt;\n1    4207.\n\n\nOr we can also drop NA values entirely and modify our original dataset\n\npenguins &lt;- penguins |&gt; \n  na.omit()\n\npenguins |&gt; \n  summarize(ave_mass = mean(body_mass_g))\n\n# A tibble: 1 × 1\n  ave_mass\n     &lt;dbl&gt;\n1    4207.\n\n\nA powerful paradigm is to first group and then summarize:\n\npenguins |&gt; \n  group_by(species, island) |&gt; \n  summarize(ave_mass = mean(body_mass_g))\n\n`summarise()` has grouped output by 'species'. You can override using the\n`.groups` argument.\n\n\n# A tibble: 5 × 3\n# Groups:   species [3]\n  species   island    ave_mass\n  &lt;fct&gt;     &lt;fct&gt;        &lt;dbl&gt;\n1 Adelie    Biscoe       3710.\n2 Adelie    Dream        3701.\n3 Adelie    Torgersen    3709.\n4 Chinstrap Dream        3733.\n5 Gentoo    Biscoe       5092."
  },
  {
    "objectID": "intro-singlecell.html#visualization",
    "href": "intro-singlecell.html#visualization",
    "title": "Introduction to single cell data science",
    "section": "Visualization",
    "text": "Visualization\nThese data can also be piped into functions for data visualization:\n\npenguins |&gt; \n  ggplot(aes(species, body_mass_g)) +\n  geom_boxplot(aes(fill=species))"
  },
  {
    "objectID": "intro-singlecell.html#dimensionality-reduction",
    "href": "intro-singlecell.html#dimensionality-reduction",
    "title": "Introduction to single cell data science",
    "section": "Dimensionality reduction",
    "text": "Dimensionality reduction\nNext, we will work towards using dimensionality reduction to visualize the penguins in the principal components space.\nFor the four columns that contain mm or mass, we apply scale(), which centers and scales each variable.\n\npenguins |&gt; \n  mutate(across(contains(c(\"mm\",\"mass\")), scale))\n\n# A tibble: 333 × 8\n   species island    bill_length_mm[,1] bill_depth_mm[,1] flipper_length_mm[,1]\n   &lt;fct&gt;   &lt;fct&gt;                  &lt;dbl&gt;             &lt;dbl&gt;                 &lt;dbl&gt;\n 1 Adelie  Torgersen             -0.895             0.780                -1.42 \n 2 Adelie  Torgersen             -0.822             0.119                -1.07 \n 3 Adelie  Torgersen             -0.675             0.424                -0.426\n 4 Adelie  Torgersen             -1.33              1.08                 -0.568\n 5 Adelie  Torgersen             -0.858             1.74                 -0.782\n 6 Adelie  Torgersen             -0.931             0.323                -1.42 \n 7 Adelie  Torgersen             -0.876             1.24                 -0.426\n 8 Adelie  Torgersen             -0.529             0.221                -1.35 \n 9 Adelie  Torgersen             -0.986             2.05                 -0.711\n10 Adelie  Torgersen             -1.72              2.00                 -0.212\n# ℹ 323 more rows\n# ℹ 3 more variables: body_mass_g &lt;dbl[,1]&gt;, sex &lt;fct&gt;, year &lt;int&gt;\n\n\nVisualizing the scaled data (i.e. y-axis has changed, but distribution is the same).\n\npenguins |&gt; \n  mutate(across(contains(c(\"mm\",\"mass\")), scale)) |&gt; \n  ggplot(aes(species, body_mass_g)) +\n  geom_boxplot(aes(fill=species))\n\n\n\n\nLet’s create a new matrix called scaled with just the four columns scaled.\n\nscaled &lt;- penguins |&gt; \n  select(contains(c(\"mm\",\"mass\"))) |&gt; \n  mutate(across(everything(), scale))\nscaled\n\n# A tibble: 333 × 4\n   bill_length_mm[,1] bill_depth_mm[,1] flipper_length_mm[,1] body_mass_g[,1]\n                &lt;dbl&gt;             &lt;dbl&gt;                 &lt;dbl&gt;           &lt;dbl&gt;\n 1             -0.895             0.780                -1.42           -0.568\n 2             -0.822             0.119                -1.07           -0.506\n 3             -0.675             0.424                -0.426          -1.19 \n 4             -1.33              1.08                 -0.568          -0.940\n 5             -0.858             1.74                 -0.782          -0.692\n 6             -0.931             0.323                -1.42           -0.723\n 7             -0.876             1.24                 -0.426           0.581\n 8             -0.529             0.221                -1.35           -1.25 \n 9             -0.986             2.05                 -0.711          -0.506\n10             -1.72              2.00                 -0.212           0.240\n# ℹ 323 more rows\n\n\nThen, we can apply the function prcomp() to calculate the principal components 1 to 4.\nUnder the hood, the function uses a singular value decomposition of the centered and scaled data matrix (not using eigen on the covariance matrix). Often preferred for numerical accuracy.\n\nscaled |&gt; \n  prcomp() \n\nStandard deviations (1, .., p=4):\n[1] 1.6569115 0.8821095 0.6071594 0.3284579\n\nRotation (n x k) = (4 x 4):\n                         PC1         PC2        PC3        PC4\nbill_length_mm     0.4537532 -0.60019490 -0.6424951  0.1451695\nbill_depth_mm     -0.3990472 -0.79616951  0.4258004 -0.1599044\nflipper_length_mm  0.5768250 -0.00578817  0.2360952 -0.7819837\nbody_mass_g        0.5496747 -0.07646366  0.5917374  0.5846861\n\n\nSome useful things about output:\n\npca &lt;- scaled |&gt; \n  prcomp()\n\nnames(pca)\n\n[1] \"sdev\"     \"rotation\" \"center\"   \"scale\"    \"x\"       \n\ndim(pca$x)\n\n[1] 333   4\n\nhead(pca$x)\n\n           PC1         PC2         PC3        PC4\n[1,] -1.850808 -0.03202119  0.23454869  0.5276026\n[2,] -1.314276  0.44286031  0.02742880  0.4011230\n[3,] -1.374537  0.16098821 -0.18940423 -0.5278675\n[4,] -1.882455  0.01233268  0.62792772 -0.4721826\n[5,] -1.917096 -0.81636958  0.69999797 -0.1961213\n[6,] -1.770356  0.36567266 -0.02841769  0.5046092\n\n\nVisualize\n\npenguins |&gt; \n  bind_cols(pca$x) |&gt; \n  ggplot(aes(PC1, PC2, color=species)) + \n  geom_point()"
  },
  {
    "objectID": "intro-singlecell.html#learning-objectives-2",
    "href": "intro-singlecell.html#learning-objectives-2",
    "title": "Introduction to single cell data science",
    "section": "Learning objectives",
    "text": "Learning objectives\n\nBe able to create a single-cell count matrix and read it into R\nRecognize and define the SingleCellExperiment S4 class in R/Bioconductor to store single-cell data\nBe able to describe a standard workflow for analyzing single-cell data\nBe able to run code for a standard workflow starting from loading a SingleCellExperiment in R and identifying clusters."
  },
  {
    "objectID": "intro-singlecell.html#overview",
    "href": "intro-singlecell.html#overview",
    "title": "Introduction to single cell data science",
    "section": "Overview",
    "text": "Overview\nNGS data from scRNA-seq experiments must be converted into a matrix of expression values.\nThis is usually a count matrix containing the number of reads (or UMIs) mapped to each gene (row) in each cell (column). Once this quantification is complete, we can proceed with our downstream statistical analyses in R.\nConstructing a count matrix from raw scRNA-seq data requires some thought as the term “single-cell RNA-seq” encompasses a variety of different experimental protocols."
  },
  {
    "objectID": "intro-singlecell.html#singlecellexperiment-class",
    "href": "intro-singlecell.html#singlecellexperiment-class",
    "title": "Introduction to single cell data science",
    "section": "SingleCellExperiment Class",
    "text": "SingleCellExperiment Class\nOne of the main strengths of the Bioconductor project lies in the use of a common data infrastructure that powers interoperability across packages.\nUsers should be able to analyze their data using functions from different Bioconductor packages without the need to convert between formats.\nTo this end, the SingleCellExperiment class (from the SingleCellExperiment package) serves as the common currency for data exchange across 70+ single-cell-related Bioconductor packages.\nThis class implements a data structure that stores all aspects of our single-cell data - gene-by-cell expression data, per-cell metadata and per-gene annotation - and manipulate them in a synchronized manner.\n\n\n\n\n\n\n\n\n\n[source]\n\nEach piece of (meta)data in the SingleCellExperiment is represented by a separate “slot”.\n\n(This terminology comes from the S4 class system, but that’s not important right now).\nIf we imagine the SingleCellExperiment object to be a cargo ship, the slots can be thought of as individual cargo boxes with different contents, e.g., certain slots expect numeric matrices whereas others may expect data frames.\nIf you want to know more about the available slots, their expected formats, and how we can interact with them, check out this chapter.\n\nSingleCellExperiment Example\nLet’s show you what a SingleCellExperiment (or sce for short) looks like.\n\nsce\n\nclass: SingleCellExperiment \ndim: 20006 3005 \nmetadata(0):\nassays(1): counts\nrownames(20006): Tspan12 Tshz1 ... mt-Rnr1 mt-Nd4l\nrowData names(1): featureType\ncolnames(3005): 1772071015_C02 1772071017_G12 ... 1772066098_A12\n  1772058148_F03\ncolData names(10): tissue group # ... level1class level2class\nreducedDimNames(0):\nmainExpName: endogenous\naltExpNames(2): ERCC repeat\n\n\nThis SingleCellExperiment object has 20006 genes and 3005 cells.\nWe can pull out the counts matrix with the counts() function and the corresponding rowData() and colData():\n\ncounts(sce)[1:5, 1:5]\n\n         1772071015_C02 1772071017_G12 1772071017_A05 1772071014_B06\nTspan12               0              0              0              3\nTshz1                 3              1              0              2\nFnbp1l                3              1              6              4\nAdamts15              0              0              0              0\nCldn12                1              1              1              0\n         1772067065_H06\nTspan12               0\nTshz1                 2\nFnbp1l                1\nAdamts15              0\nCldn12                0\n\nrowData(sce)\n\nDataFrame with 20006 rows and 1 column\n         featureType\n         &lt;character&gt;\nTspan12   endogenous\nTshz1     endogenous\nFnbp1l    endogenous\nAdamts15  endogenous\nCldn12    endogenous\n...              ...\nmt-Co2          mito\nmt-Co1          mito\nmt-Rnr2         mito\nmt-Rnr1         mito\nmt-Nd4l         mito\n\ncolData(sce)\n\nDataFrame with 3005 rows and 10 columns\n                       tissue   group # total mRNA mol      well       sex\n                  &lt;character&gt; &lt;numeric&gt;      &lt;numeric&gt; &lt;numeric&gt; &lt;numeric&gt;\n1772071015_C02       sscortex         1           1221         3         3\n1772071017_G12       sscortex         1           1231        95         1\n1772071017_A05       sscortex         1           1652        27         1\n1772071014_B06       sscortex         1           1696        37         3\n1772067065_H06       sscortex         1           1219        43         3\n...                       ...       ...            ...       ...       ...\n1772067059_B04 ca1hippocampus         9           1997        19         1\n1772066097_D04 ca1hippocampus         9           1415        21         1\n1772063068_D01       sscortex         9           1876        34         3\n1772066098_A12 ca1hippocampus         9           1546        88         1\n1772058148_F03       sscortex         9           1970        15         3\n                     age  diameter        cell_id       level1class level2class\n               &lt;numeric&gt; &lt;numeric&gt;    &lt;character&gt;       &lt;character&gt; &lt;character&gt;\n1772071015_C02         2         1 1772071015_C02      interneurons       Int10\n1772071017_G12         1       353 1772071017_G12      interneurons       Int10\n1772071017_A05         1        13 1772071017_A05      interneurons        Int6\n1772071014_B06         2        19 1772071014_B06      interneurons       Int10\n1772067065_H06         6        12 1772067065_H06      interneurons        Int9\n...                  ...       ...            ...               ...         ...\n1772067059_B04         4       382 1772067059_B04 endothelial-mural       Peric\n1772066097_D04         7        12 1772066097_D04 endothelial-mural        Vsmc\n1772063068_D01         7       268 1772063068_D01 endothelial-mural        Vsmc\n1772066098_A12         7       324 1772066098_A12 endothelial-mural        Vsmc\n1772058148_F03         7         6 1772058148_F03 endothelial-mural        Vsmc"
  },
  {
    "objectID": "intro-singlecell.html#a-typical-single-cell-workflow",
    "href": "intro-singlecell.html#a-typical-single-cell-workflow",
    "title": "Introduction to single cell data science",
    "section": "A typical single-cell workflow",
    "text": "A typical single-cell workflow\nHere, we provide an overview of the framework of a typical scRNA-seq analysis workflow:\n\n\n\n\n\n\n\n\n\nIn the simplest case, the workflow has the following form:\n\nWe compute quality control metrics to remove low-quality cells that would interfere with downstream analyses. These cells may have been damaged during processing or may not have been fully captured by the sequencing protocol. Common metrics includes the total counts per cell, the proportion of spike-in or mitochondrial reads and the number of detected features.\nWe convert the counts into normalized expression values to eliminate cell-specific biases (e.g., in capture efficiency). This allows us to perform explicit comparisons across cells in downstream steps like clustering. We also apply a transformation, typically log, to adjust for the mean-variance relationship.\nWe perform feature selection to pick a subset of interesting features for downstream analysis. This is done by modelling the variance across cells for each gene and retaining genes that are highly variable. The aim is to reduce computational overhead and noise from uninteresting genes.\nWe apply dimensionality reduction to compact the data and further reduce noise. Principal components analysis is typically used to obtain an initial low-rank representation for more computational work, followed by more aggressive methods like \\(t\\)-stochastic neighbor embedding for visualization purposes.\nWe cluster cells into groups according to similarities in their (normalized) expression profiles. This aims to obtain groupings that serve as empirical proxies for distinct biological states. We typically interpret these groupings by identifying differentially expressed marker genes between clusters."
  },
  {
    "objectID": "intro-singlecell.html#quick-start-simple",
    "href": "intro-singlecell.html#quick-start-simple",
    "title": "Introduction to single cell data science",
    "section": "Quick start (simple)",
    "text": "Quick start (simple)\nHere, we use the a droplet-based retina dataset from Macosko et al. (2015), provided in the scRNAseq package. This starts from a count matrix and finishes with clusters in preparation for biological interpretation. We also demonstrate how to identify differentially expressed genes between the clusters.\n\nlibrary(scRNAseq)\nsce &lt;- MacoskoRetinaData()\n\nsee ?scRNAseq and browseVignettes('scRNAseq') for documentation\n\n\nloading from cache\n\n\nsee ?scRNAseq and browseVignettes('scRNAseq') for documentation\n\n\nloading from cache\n\n# Quality control (using mitochondrial genes).\nlibrary(scater)\n\nLoading required package: scuttle\n\nis.mito &lt;- grepl(\"^MT-\", rownames(sce)) # find mitochondrial genes\nqcstats &lt;- perCellQCMetrics(sce, subsets=list(Mito=is.mito)) # calculate QC metrics \nfiltered &lt;- quickPerCellQC(qcstats, percent_subsets=\"subsets_Mito_percent\") # filter base on QC metrics\nsce &lt;- sce[, !filtered$discard] # subset object for post-QC analyses\n\n# Normalization.\nsce &lt;- logNormCounts(sce)\n\n# Feature selection (which genes are most important)? \nlibrary(scran)\ndec.retina &lt;- modelGeneVar(sce)\nhvg &lt;- getTopHVGs(dec.retina, prop=0.1)\n\n# Visualizing the fit:\nfit.retina &lt;- metadata(dec.retina)\nplot(fit.retina$mean, fit.retina$var, xlab=\"Mean of log-expression\",\n    ylab=\"Variance of log-expression\")\ncurve(fit.retina$trend(x), col=\"dodgerblue\", add=TRUE, lwd=2)\n\n\n\n\n\n# PCA\nlibrary(scater)\nset.seed(1234)\nsce &lt;- runPCA(sce, ncomponents=25, subset_row=hvg)\n\n# Clustering.\nlibrary(bluster)\ncolLabels(sce) &lt;- clusterCells(sce, use.dimred='PCA',\n    BLUSPARAM=NNGraphParam(cluster.fun=\"louvain\"))  \n\n\n# Visualization of PC1 vs PC2\nplotPCA(sce, colour_by=\"label\")\n\n\n\n\n\n# UMAP visualization \nsce &lt;- runUMAP(sce, dimred = 'PCA')\nplotUMAP(sce, colour_by=\"label\")\n\n\n\n\nUMAP plot of the retina dataset, where each point is a cell and is colored by the assigned cluster identity."
  },
  {
    "objectID": "intro-singlecell.html#for-more-information",
    "href": "intro-singlecell.html#for-more-information",
    "title": "Introduction to single cell data science",
    "section": "For more information",
    "text": "For more information\nIf you could like to know more, check out this book:\n\nhttps://bioconductor.org/books/release/OSCA/"
  },
  {
    "objectID": "intro-singlecell.html#overview-1",
    "href": "intro-singlecell.html#overview-1",
    "title": "Introduction to single cell data science",
    "section": "Overview",
    "text": "Overview\n\nsuppressPackageStartupMessages({\n  library(tidySummarizedExperiment) # allow dplyr\n})\n\n\nsce |&gt;\n  addPerCellQC(subsets=list(Mito=is.mito)) |&gt;\n  colData()\n\nDataFrame with 45877 rows and 10 columns\n                        cell.id   cluster sizeFactor    label       sum\n                    &lt;character&gt; &lt;integer&gt;  &lt;numeric&gt; &lt;factor&gt; &lt;numeric&gt;\nr1_GGCCGCAGTCCG r1_GGCCGCAGTCCG         2    28.0131        1     37487\nr1_CTTGTGCGGGAA r1_CTTGTGCGGGAA         2    23.9479        1     32047\nr1_GCGCAACTGCTC r1_GCGCAACTGCTC         2    21.0343        1     28148\nr1_GATTGGGAGGCA r1_GATTGGGAGGCA         2    15.2197        1     20367\nr1_CCTCCTAGTTGG r1_CCTCCTAGTTGG        NA    14.6167        1     19560\n...                         ...       ...        ...      ...       ...\np1_TCAAAAGCCGGG p1_TCAAAAGCCGGG        24   0.610523       13       817\np1_ATTAAGTTCCAA p1_ATTAAGTTCCAA        34   0.610523       5        817\np1_CTGTCTGAGACC p1_CTGTCTGAGACC         2   0.610523       1        817\np1_TAACGCGCTCCT p1_TAACGCGCTCCT        24   0.609776       11       816\np1_ATTCTTGTTCTT p1_ATTCTTGTTCTT        24   0.609776       8        816\n                 detected subsets_Mito_sum subsets_Mito_detected\n                &lt;integer&gt;        &lt;numeric&gt;             &lt;integer&gt;\nr1_GGCCGCAGTCCG      7243              427                    14\nr1_CTTGTGCGGGAA      6933              503                    15\nr1_GCGCAACTGCTC      6397              460                    13\nr1_GATTGGGAGGCA      5740              326                    11\nr1_CCTCCTAGTTGG      5779              264                     9\n...                   ...              ...                   ...\np1_TCAAAAGCCGGG       537               13                     4\np1_ATTAAGTTCCAA       574               10                     5\np1_CTGTCTGAGACC       637               24                     7\np1_TAACGCGCTCCT       488               27                     5\np1_ATTCTTGTTCTT       484               16                     4\n                subsets_Mito_percent     total\n                           &lt;numeric&gt; &lt;numeric&gt;\nr1_GGCCGCAGTCCG              1.13906     37487\nr1_CTTGTGCGGGAA              1.56957     32047\nr1_GCGCAACTGCTC              1.63422     28148\nr1_GATTGGGAGGCA              1.60063     20367\nr1_CCTCCTAGTTGG              1.34969     19560\n...                              ...       ...\np1_TCAAAAGCCGGG              1.59119       817\np1_ATTAAGTTCCAA              1.22399       817\np1_CTGTCTGAGACC              2.93758       817\np1_TAACGCGCTCCT              3.30882       816\np1_ATTCTTGTTCTT              1.96078       816\n\n\n\n# Identify variable genes with scran\nvariable_genes &lt;-\n    sce %&gt;%\n    modelGeneVar() %&gt;%\n    getTopHVGs(prop=0.1)\n\n\n# Perform PCA with scater\nretina_pca &lt;-\n    sce %&gt;%\n    runPCA(subset_row=variable_genes)\n\nplotPCA(retina_pca, colour_by=\"label\")"
  }
]